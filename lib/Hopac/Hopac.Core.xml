<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Hopac.Core</name>
    </assembly>
    <members>
        <member name="T:Hopac.Ch`1">
            <summary>Represents a synchronous channel.</summary>
        </member>
        <member name="T:Hopac.Alt`1">
            <summary>Represents a first class synchronous operation.</summary>
        </member>
        <member name="T:Hopac.Job`1">
            <summary>Represents a lightweight thread of execution.</summary>
        </member>
        <member name="T:Hopac.Core.ChGive`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.ChGive`1.#ctor(Hopac.Ch{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.ChSend`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.ChSend`1.#ctor(Hopac.Ch{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.ChTryGive`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.ChTryGive`1.#ctor(Hopac.Ch{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.ChTryTake`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.ChTryTake`1.#ctor(Hopac.Ch{`0})">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.IVar`1">
            <summary>Represents a write once variable.</summary>
        </member>
        <member name="T:Hopac.Promise`1">
            <summary>Represents a promise to produce a result at some point in the
            future.</summary>
        </member>
        <member name="M:Hopac.Promise`1.#ctor(Hopac.Job{`0})">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Promise`1.#ctor(`0)">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Promise`1.#ctor(System.Exception)">
            Internal implementation detail.
        </member>
        <member name="P:Hopac.Promise`1.Full">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.Cont`1">
            <summary>Represents a continuation of a parallel job.</summary>
        </member>
        <member name="T:Hopac.Core.Work">
            <summary>Work item.</summary>
        </member>
        <member name="T:Hopac.Core.Handler">
            <summary>Exception handling continuation.</summary>
        </member>
        <member name="M:Hopac.Core.Handler.DoHandle(Hopac.Core.Worker@,System.Exception)">
            <summary>Do not call this directly unless you know that the handler is not null.</summary>
        </member>
        <member name="M:Hopac.Core.Handler.GetProc(Hopac.Core.Worker@)">
            <summary>Do not call this directly unless you know that the handler is not null.</summary>
        </member>
        <member name="T:Hopac.Core.Cont`1">
            <summary>Represents a continuation of a parallel job.</summary>
        </member>
        <member name="T:Hopac.Core.Work">
            <summary>Work item.</summary>
        </member>
        <member name="M:Hopac.Core.Cont`1.DoCont(Hopac.Core.Worker@,`0)">
            Use DoCont when NOT invoking continuation from a Job or Alt.
        </member>
        <member name="M:Hopac.IVar`1.#ctor">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.IVar`1.#ctor(`0)">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.IVar`1.#ctor(System.Exception)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.IVar`1.Fill">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.IVar`1.Fill.#ctor(Hopac.IVar{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.IVar`1.TryFill">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.IVar`1.TryFill.#ctor(Hopac.IVar{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.IVar`1.FillFailure">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.IVar`1.FillFailure.#ctor(Hopac.IVar{`0},System.Exception)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Latch">
            <summary>Represents a dynamic latch.</summary>
        </member>
        <member name="M:Hopac.Latch.#ctor(System.Int32)">
            
        </member>
        <member name="M:Hopac.Latch.Increment">
            
        </member>
        <member name="M:Hopac.Latch.Decrement">
            
        </member>
        <member name="T:Hopac.Lock">
            <summary>A non-recursive mutual exclusion lock for jobs.</summary>
        </member>
        <member name="T:Hopac.Core.LockDuringFun`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.LockDuringFun`1.#ctor(Hopac.Lock,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,`0})">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.LockDuringJob`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.LockDuringJob`1.#ctor(Hopac.Lock,Hopac.Job{`0})">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Mailbox`1">
            <summary>Represents a asynchronous, unbounded buffered mailbox.</summary>
        </member>
        <member name="M:Hopac.Mailbox`1.#ctor">
            <summary>Constructs a new empty mailbox.</summary>
        </member>
        <member name="T:Hopac.Core.MailboxSend`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.MailboxSend`1.#ctor(Hopac.Mailbox{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.MVar`1">
            <summary>Represents a serialized variable.</summary>
        </member>
        <member name="M:Hopac.MVar`1.#ctor">
            <summary>Creates an initially empty MVar.</summary>
        </member>
        <member name="M:Hopac.MVar`1.#ctor(`0)">
            <summary>Creates an MVar initially filled with the given
            value.</summary>
        </member>
        <member name="T:Hopac.Core.MVarFill`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.MVarFill`1.#ctor(Hopac.MVar{`0},`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Once`1">
            
        </member>
        <member name="M:Hopac.Once`1.#ctor(`0)">
            
        </member>
        <member name="M:Hopac.Core.WaitQueue.AddGiver``1(Hopac.Core.Send{``0}@,``0,System.Int32,Hopac.Core.Pick,Hopac.Core.Cont{Microsoft.FSharp.Core.Unit})">
            <summary>Note that this specifically tries to reuse a giver from the
            queue.  This reduces the chance of space leaks.</summary>
        </member>
        <member name="M:Hopac.Core.WaitQueue.AddGiver``1(Hopac.Core.Send{``0}@,``0,Hopac.Core.Cont{Microsoft.FSharp.Core.Unit})">
            <summary>Note that this specifically tries to reuse a giver from the
            queue.  This reduces the chance of space leaks.</summary>
        </member>
        <member name="M:Hopac.Core.WaitQueue.AddTaker``1(Hopac.Core.Cont{``0}@,System.Int32,Hopac.Core.Pick,Hopac.Core.Cont{``0})">
            <summary>Note that this specifically tries to reuse a taker from the
            queue.  This reduces the chance of space leaks.</summary>
        </member>
        <member name="T:Hopac.Scheduler">
            <summary>Represents a scheduler that manages a number of worker
            threads.</summary>
        </member>
        <member name="M:Hopac.Scheduler.Kill(Hopac.Scheduler)">
            <summary>Kills the worker threads of the scheduler one-by-one.  This
            should only be used with a local scheduler that is known to be
            idle.</summary>
        </member>
        <member name="T:Hopac.Core.StaticData">
            <summary>This class contains some special static data used by the Hopac
            library internal implementation.  The static members of this class are
            normally implicitly initialized by the Hopac library, but it is possible
            to write a program that accesses these variables too early.  In such a
            corner case the program should explicitly arrange the `Init` method of
            this class to be called.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.isMono">
            <summary>Whether we are on Mono rather than .Net.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.unit">
            <summary>Stores the single shared unit alternative.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.zero">
            <summary>Stores the single shared zero alternative.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.scheduler">
            <summary>Stores the single shared scheduler job.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.proc">
            <summary>Stores the single shared proc job.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.switchToWorker">
            <summary>Stores the single shared proc that switches execution to a
            worker thread.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.random">
            <summary>Stores the single shared proc that generates a random
            number.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.workAsyncCallback">
            <summary>Stores the single AsyncCallback delegate.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.writeLine">
            <summary>Stores an action for printing diagnostics.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.createScheduler">
            <summary>Function for creating a scheduler.</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.globalScheduler">
            <summary>The global scheduler (if it has been created).</summary>
        </member>
        <member name="F:Hopac.Core.StaticData.globalTimer">
            <summary>The global timer (if it has been created).</summary>
        </member>
        <member name="M:Hopac.Core.StaticData.Init">
            <summary>This is normally called automatically by Hopac library code.
            This is safe to be called from multiple threads.</summary>
        </member>
        <member name="T:Hopac.Core.JobFromBeginEnd`1">
            
        </member>
        <member name="M:Hopac.Core.JobFromBeginEnd`1.DoBegin(System.AsyncCallback,System.Object)">
            
        </member>
        <member name="M:Hopac.Core.JobFromBeginEnd`1.DoEnd(System.IAsyncResult)">
            
        </member>
        <member name="T:Hopac.Core.BindTaskWithResult`2">
            
        </member>
        <member name="M:Hopac.Core.BindTaskWithResult`2.#ctor(System.Threading.Tasks.Task{`0})">
            
        </member>
        <member name="M:Hopac.Core.BindTaskWithResult`2.Do(`0)">
            
        </member>
        <member name="T:Hopac.Core.BindTask`1">
            
        </member>
        <member name="M:Hopac.Core.BindTask`1.#ctor(System.Threading.Tasks.Task)">
            
        </member>
        <member name="M:Hopac.Core.BindTask`1.Do">
            
        </member>
        <member name="T:Hopac.Core.AwaitTaskWithResult`1">
            
        </member>
        <member name="M:Hopac.Core.AwaitTaskWithResult`1.#ctor(System.Threading.Tasks.Task{`0})">
            
        </member>
        <member name="T:Hopac.Core.AwaitTask">
            
        </member>
        <member name="M:Hopac.Core.AwaitTask.#ctor(System.Threading.Tasks.Task)">
            
        </member>
        <member name="T:Hopac.Core.ContIterate`2">
            
        </member>
        <member name="M:Hopac.Core.ContIterate`2.#ctor(`0,Hopac.Core.Cont{`1})">
            
        </member>
        <member name="M:Hopac.Core.ContIterate`2.Do(`0)">
            
        </member>
        <member name="M:Hopac.Core.Cont.Do``1(Hopac.Core.Cont{``0},Hopac.Core.Worker@,``0)">
            Use Cont.Do when invoking continuation from a Job or Alt.
        </member>
        <member name="T:Hopac.Core.JobBind`2">
            
        </member>
        <member name="M:Hopac.Core.JobBind`2.#ctor(Hopac.Job{`0})">
            
        </member>
        <member name="M:Hopac.Core.JobBind`2.Do(`0)">
            
        </member>
        <member name="T:Hopac.Core.JobJoin`2">
            
        </member>
        <member name="M:Hopac.Core.JobJoin`2.#ctor(Hopac.Job{`1})">
            
        </member>
        <member name="T:Hopac.Core.JobTryIn`2">
            
        </member>
        <member name="M:Hopac.Core.JobTryIn`2.#ctor(Hopac.Job{`0})">
            
        </member>
        <member name="M:Hopac.Core.JobTryIn`2.DoIn(`0)">
            
        </member>
        <member name="M:Hopac.Core.JobTryIn`2.DoExn(System.Exception)">
            
        </member>
        <member name="T:Hopac.Core.JobTryWith`1">
            
        </member>
        <member name="M:Hopac.Core.JobTryWith`1.#ctor(Hopac.Job{`0})">
            
        </member>
        <member name="M:Hopac.Core.JobTryWith`1.DoExn(System.Exception)">
            
        </member>
        <member name="T:Hopac.Core.JobMap`2">
            
        </member>
        <member name="M:Hopac.Core.JobMap`2.#ctor(Hopac.Job{`0})">
            
        </member>
        <member name="M:Hopac.Core.JobMap`2.Do(`0)">
            
        </member>
        <member name="T:Hopac.Core.JobRun`1">
            
        </member>
        <member name="M:Hopac.Core.JobRun`1.Do(Hopac.Core.Cont{`0})">
            
        </member>
        <member name="T:Hopac.Core.JobStart">
            
        </member>
        <member name="M:Hopac.Core.JobStart.Do">
            
        </member>
        <member name="T:Hopac.Core.JobDelay`1">
            
        </member>
        <member name="M:Hopac.Core.JobDelay`1.Do">
            
        </member>
        <member name="T:Hopac.Core.JobThunk`1">
            
        </member>
        <member name="M:Hopac.Core.JobThunk`1.Do">
            
        </member>
        <member name="T:Hopac.Core.JobRandomBind`1">
            
        </member>
        <member name="M:Hopac.Core.JobRandomBind`1.Do(System.UInt64)">
            
        </member>
        <member name="T:Hopac.Core.JobRandomMap`1">
            
        </member>
        <member name="M:Hopac.Core.JobRandomMap`1.Do(System.UInt64)">
            
        </member>
        <member name="T:Hopac.Core.JobRandomGet">
            
        </member>
        <member name="M:Hopac.Core.JobRandomGet.DoJob(Hopac.Core.Worker@,Hopac.Core.Cont{System.UInt64})">
            
        </member>
        <member name="T:Hopac.Proc">
            <summary>Represents a joinable lightweight thread of execution.</summary>
        </member>
        <member name="T:Hopac.Core.AltBind`2">
            
        </member>
        <member name="M:Hopac.Core.AltBind`2.#ctor(Hopac.Alt{`0})">
            
        </member>
        <member name="M:Hopac.Core.AltBind`2.Do(`0)">
            
        </member>
        <member name="T:Hopac.Core.AltMap`2">
            
        </member>
        <member name="M:Hopac.Core.AltMap`2.#ctor(Hopac.Alt{`0})">
            
        </member>
        <member name="M:Hopac.Core.AltMap`2.Do(`0)">
            
        </member>
        <member name="T:Hopac.Core.AltDelay`1">
            
        </member>
        <member name="M:Hopac.Core.AltDelay`1.Do">
            
        </member>
        <member name="T:Hopac.Core.AltRandom`1">
            
        </member>
        <member name="M:Hopac.Core.AltRandom`1.Do(System.UInt64)">
            
        </member>
        <member name="T:Hopac.Core.Always`1">
            Internal implementation detail.
        </member>
        <member name="M:Hopac.Core.Always`1.#ctor(`0)">
            Internal implementation detail.
        </member>
        <member name="T:Hopac.Core.Never`1">
            
        </member>
        <member name="T:Hopac.Core.Condition">
            <summary>Provides a low overhead, single shot waitable event.</summary>
        </member>
        <member name="T:Hopac.Core.SpinlockTTAS">
            <summary>Provides a low overhead spinlock that is about as fast as
            possible in case of low contention, but also becomes slow in case of
            contention.  On every change of owner this spinlock implementation
            requires Omega(n) cache line transfers, where n is the number of threads
            waiting for the lock, and is thus inherently unscalable.</summary>
        </member>
    </members>
</doc>
