<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Hopac</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJobBuilder">
<summary>
 A builder for embedded jobs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJob`1">
<summary>
 Represents a job to be embedded within a computation built upon jobs.
</summary>
</member>
<member name="M:Hopac.IAsyncDisposable.DisposeAsync">
<summary>
 Returns a job that needs to be executed to dispose the resource.
</summary>
</member>
<member name="T:Hopac.IAsyncDisposable">
<summary>
 An experimental interface for asynchronously disposable resources.  See
 also: `usingAsync`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.JobBuilder">
<summary>
 Expression builder type for jobs.
</summary>
</member>
<member name="T:Hopac.Void">
<summary>
 A type that has no public constructors to indicate that a job or function
 does not return normally.
</summary>
</member>
<member name="M:Hopac.Alt.paranoid``1(Hopac.Alt{``0})">
<summary>
 Given an alternative, creates a new alternative that behaves exactly like
 the given alternative, except that the new alternative obviously cannot be
 directly downcast to the underlying type of the given alternative.  This
 operation is provided for debugging purposes.  You can always break
 abstractions using reflection.  See also: `Job.paranoid`.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyJob``1(Hopac.Alt{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a job, is executed after
 the alternative has been committed to, whether the alternative fails or
 completes successfully.  Note that the action is not executed in case the
 alternative is not committed to.  Use `withNack` to attach the action to
 the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyFun``1(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a function, is executed
 after the alternative has been committed to, whether the alternative fails
 or completes successfully.  Note that the action is not executed in case
 the alternative is not committed to.  Use `withNack` to attach the action
 to the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryIn``4(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for
 alternatives.  Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success,
 and `exn -&gt; Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.

 Exceptions from both before and after the commit point can be handled.  An
 exception that occurs before a commit point, from the user code in a
 `guard`, `delay`, or `withNack`, results in treating that exception as the
 commit point.

 Note you can also use function or job level exception handling before the
 commit point within the user code in a `guard`, `delay`, or `withNack`.
</summary>
</member>
<member name="M:Hopac.Alt.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 `xA |&gt; map x2y` is equivalent to `xA |&gt; wrap (x2y &gt;&gt; result)`.  This is
 the same as `|&gt;&gt;?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.wrap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 Creates an alternative whose result is passed to the given job constructor
 and processed with the resulting job after the given alternative has been
 committed to.  This is the same as `&gt;&gt;=?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.chooser``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 `chooser xAs` is like `choose xAs` except that the order in which the
 alternatives from the sequence are considered will be determined at random
 each time the alternative is used.  See also: `&lt;~&gt;?`.
</summary>
</member>
<member name="M:Hopac.Alt.choose``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an alternative that is available when any one of the given
 alternatives is.  See also: `&lt;|&gt;?`.

 Note that `choose []` is equivalent to `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.withNack``3(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job constructed with a negative acknowledgment alternative.  See
 also: `guard`.
</summary>
</member>
<member name="M:Hopac.Alt.random``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 the given function, which will be called with a pseudo random 64-bit
 unsigned integer.  See also: `Random.bind`.
</summary>
</member>
<member name="M:Hopac.Alt.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given thunk.

 `delay` is an optimized weaker form of `guard` that can be used when no
 concurrent operations beyond the returned alternative are required by the
 encapsulated request protocol.
</summary>
</member>
<member name="M:Hopac.Alt.guard``2(Hopac.Job{``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job.  See also: `withNack`.
</summary>
</member>
<member name="M:Hopac.Alt.raises``1(System.Exception)">
<summary>
 Creates an alternative that has the effect of raising the specified
 exception.  `raises e` is equivalent to `delay &lt;| fun () -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.once``1(``0)">
<summary>
 Returns an alternative that can be committed to once and that produces the
 given value.
</summary>
</member>
<member name="M:Hopac.Alt.zero">
<summary>
 Returns an alternative that is never available.  `zero ()` is an optimized
 version of `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.never``1">
<summary>
 Creates an alternative that is never available.

 Note that synchronizing on `never ()`, without other alternatives, is
 equivalent to performing `abort ()`.
</summary>
</member>
<member name="M:Hopac.Alt.unit">
<summary>
 Returns an alternative that is always available and results in the unit
 value.  `unit ()` is an optimized version of `always ()`.
</summary>
</member>
<member name="M:Hopac.Alt.always``1(``0)">
<summary>
 Creates an alternative that is always available and results in the given
 value.

 Note that when there are alternatives immediately available in a choice,
 the first such alternative will be committed to.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterBangQmark``2(Hopac.Alt{``0},System.Exception)">
<summary>
 `xA &gt;&gt;!? e` is equivalent to `xA &gt;&gt;=? fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterPercentQmark``2(Hopac.Alt{``0},``1)">
<summary>
 `xA &gt;&gt;%? y` is equivalent to `xA &gt;&gt;=? fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_BarGreaterGreaterQmark``2(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `xA |&gt;&gt;? x2y` is equivalent to `xA &gt;&gt;=? (x2y &gt;&gt; result)`.  This is the
 same as `map` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_DotGreaterGreaterQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA .&gt;&gt;? yJ` is equivalent to `xA &gt;&gt;=? fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterDotQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA &gt;&gt;.? yJ` is equivalent to `xA &gt;&gt;=? fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterEqualsQmark``3(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates an alternative whose result is passed to the given job
 constructor and processed with the resulting job after the given
 alternative has been committed to.  This is the same as `wrap` with the
 arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessTwiddleGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 `xA1 &lt;~&gt;? xA2` is like `xA1 &lt;|&gt;? xA2` except that the order in which
 `xA1` and `xA2` are considered is determined at random every time the
 alternative is used.  See also: `chooser`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessBarGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 Creates an alternative that is available when either of the given
 alternatives is available.  `xA1 &lt;|&gt;? xA2` is an optimized version of
 `choose [xA1; xA2]`.
</summary>
</member>
<member name="T:Hopac.Alt.Infixes">
<summary>
 Infix operators on alternatives.  You can open this module to bring all
 of the infix operators into scope.
</summary>
</member>
<member name="T:Hopac.Alt">
<summary>
 Operations on first-class synchronous operations or alternatives.
</summary>
</member>
<member name="M:Hopac.Ch.send``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.
</summary>
</member>
<member name="M:Hopac.Ch.take``1(Hopac.Ch{``0})">
<summary>
 Creates an alternative that, at instantiation time, offers to take a value
 from another job on the given channel, and becomes available when another
 job offers to give a value.
</summary>
</member>
<member name="M:Hopac.Ch.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.
</summary>
</member>
<member name="M:Hopac.Ch.create``1">
<summary>
 Creates a job that creates a new channel.
</summary>
</member>
<member name="M:Hopac.Ch.Try.take``1(Hopac.Ch{``0})">
<summary>
 Creates a job that attempts to take a value from another job waiting on
 the given channel.  Note that the other side of the communication must
 be blocked on the channel for communication to happen.
</summary>
</member>
<member name="M:Hopac.Ch.Try.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that attempts to give a value to another job waiting on
 the given channel.  The result indicates whether a value was given or
 not.  Note that the other side of the communication must be blocked on
 the channel for communication to happen.
</summary>
</member>
<member name="T:Hopac.Ch.Try">
<summary>
 Polling, or non-blocking, operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Ch.Global.send``1(Hopac.Ch{``0},``0)">
<summary>
 Sends the given value to the specified channel.

 Note that using this function in a job workflow is not optimal and you
 should use `Ch.send` instead.
</summary>
</member>
<member name="T:Hopac.Ch.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Ch.Now.create``1">
<summary>
 Creates a new channel.
</summary>
</member>
<member name="T:Hopac.Ch.Now">
<summary>
 Immediate or non-workflow operations on synchronous channels.
</summary>
</member>
<member name="T:Hopac.Ch">
<summary>
 Operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.startJob.Static``1(Hopac.Job{``0})">
<summary>
 Creates a job that starts the given job as a separate concurrent job,
 whose result can be obtained from the returned task.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``2(System.Threading.Tasks.Task,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `bindJob (uT, u2xJ)` is equivalent to `awaitJob uT &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``3(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `bindJob (xT, x2yJ)` is equivalent to `awaitJob xT &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static(System.Threading.Tasks.Task)">
<summary>
 Creates a job that waits until the given task finishes.  Note that this
 does not start the task.  Make sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static``1(System.Threading.Tasks.Task{``0})">
<summary>
 Creates a job that waits for the given task to finish and then returns
 the result of the task.  Note that this does not start the task.  Make
 sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.asyncOn(System.Threading.SynchronizationContext,Hopac.Scheduler)">
<summary>
 Builder for an async operation started on the given synchronization
 context with jobs on the specified scheduler wrapped as a job.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Extensions.Async.OnWithSchedulerBuilder">
<summary>
 Builder for async workflows.  The methods in this builder delegate to
 the default `async` builder.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.ofJobOn``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the specified
 scheduler and then waits until the started job finishes.  See also:
 `Job.scheduler`, `Async.Global.ofJob`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAltOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, posts the given async
 operation to the specified synchronization context for execution and
 then becomes enabled once the operation finishes.  Furthermore, in case
 the alternative is not committed to, the async operation is cancelled.
 As a special case, `toAltOn null xA` is equivalent to `toAlt xA`.  See
 also: `toJob`, `toJobOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAlt``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, starts the given async
 operation and then becomes enabled once the operation finishes.
 Furthermore, in case the alternative is not committed to, the async
 operation is cancelled.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJobOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that posts the given async operation to the specified
 synchronization context for execution and then waits until the operation
 finishes.  As a special case, `toJobOn null xA` is equivalent to `toJob
 xA`.  See also: `toAlt`, `toAltOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJob``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that starts the given async operation and then waits until
 the operation finishes.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.Global.ofJob``1(Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the global
 scheduler and then waits until the started job finishes.  See also:
 `Async.ofJobOn`.
</summary>
</member>
<member name="T:Hopac.Extensions.Async.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Extensions.Async">
<summary>
 Operations for interfacing F# async operations with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.foldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequentially folds the job constructor over the given sequence and
 returns the result of the fold.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially maps the given job constructor to the elements of the
 sequence and returns a list of the results.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially iterates the given job constructor over the given sequence.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished collecting the results into a list.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq.Con">
<summary>
 Operations for processing sequences using concurrent jobs.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq">
<summary>
 Operations for processing sequences with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially iterates the given job constructor over the given array.
 `Array.iterJob x2uJ xs` is an optimized version of `Seq.iterJob x2uJ
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially maps the given job constructor to the elements of the array
 and returns an array of the results.  `Array.mapJob x2yJ xs` is an
 optimized version of `Seq.mapJob x2yJ xs |&gt;&gt; fun ys -&gt; ys.ToArray ()`.
</summary>
</member>
<member name="T:Hopac.Extensions.Array">
<summary>
 Operations for processing arrays with jobs.
</summary>
</member>
<member name="T:Hopac.Extensions">
<summary>
 Extensions to various system modules and types for programming with jobs.
 You can open this module to use the extensions much like as if they were
 part of the existing modules and types.
</summary>
</member>
<member name="M:Hopac.IVar.read``1(Hopac.IVar{``0})">
<summary>
 Creates an alternative that becomes available after the write once
 variable has been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fillFailure``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  See also `fill`.
</summary>
</member>
<member name="M:Hopac.IVar.tryFill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that tries to write the given value to the given write once
 variable.  No operation takes places and no error is reported in case the
 write once variable has already been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the given write once
 variable.  It is an error to write to a single write once variable more
 than once.  This assumption may be used to optimize the implementation of
 `fill` and incorrect usage leads to undefined behavior.
</summary>
</member>
<member name="M:Hopac.IVar.create``1">
<summary>
 Creates a job that creates a new write once variable.
</summary>
</member>
<member name="M:Hopac.IVar.Now.get``1(Hopac.IVar{``0})">
<summary>
 Returns the value or raises the failure exception written to the write
 once variable.  It is considered an error if the write once variable has
 not yet been written to.

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.isFull``1(Hopac.IVar{``0})">
<summary>
 Returns true iff the given write once variable has already been filled
 (either with a value or with a failure).

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFailure``1(System.Exception)">
<summary>
 Creates a new write once variable with the given failure exception.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.
</summary>
</member>
<member name="M:Hopac.IVar.Now.create``1">
<summary>
 Creates a new write once variable.
</summary>
</member>
<member name="T:Hopac.IVar.Now">
<summary>
 Immediate or non-workflow operations on write once variables.
</summary>
</member>
<member name="T:Hopac.IVar">
<summary>
 Operations on write once variables.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusPlus``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.  `xMb &lt;&lt;-+ x` is equivalent to `Mailbox.send xMb
 x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusEquals``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xM &lt;&lt;-= x` is equivalent to `MVar.fill xM x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEqualsBang``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  `xI &lt;-=! e` is equivalent to
 `IVar.fillFailure xI e`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEquals``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes to the given write once variable.  It is an
 error to write to a single `IVar` more than once.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xI &lt;-= x` is equivalent to `IVar.fill xI x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusPlus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.  `xCh &lt;-+ x` is equivalent to
 `Ch.send xCh x`.

 Note that channels have been optimized for synchronous operations; an
 occasional send can be efficient, but when sends are queued, performance
 maybe be significantly worse than with a `Mailbox` optimized for
 buffering.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusMinus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.  `xCh &lt;-- x` is equivalent to `Ch.give xCh x`.
</summary>
</member>
<member name="T:Hopac.Infixes">
<summary>
 Additional infix operators.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.paranoid``1(Hopac.Job{``0})">
<summary>
 Given a job, creates a new job that behaves exactly like the given job,
 except that the new job obviously cannot be directly downcast to the
 underlying type of the given job.  This operation is provided for
 debugging purposes.  You can always break abstractions using reflection.
 See also: `Alt.paranoid`.
</summary>
</member>
<member name="M:Hopac.Job.switchToWorker">
<summary>
 Returns a job that ensures that the immediately following operation will
 be executed on a Hopac worker thread.
</summary>
</member>
<member name="M:Hopac.Job.scheduler">
<summary>
 Returns a job that returns the scheduler under which the job is being run.
 This allows interfacing Hopac with existing asynchronous operations that
 do not fall into a pattern that is already supported explicitly.  See, for
 example, the reference implementation of `fromBeginEnd`.  The key is that
 the job that is suspended for the duration of the asynchronous operation
 can then be resumed on the same scheduler.
</summary>
</member>
<member name="M:Hopac.Job.fromEndBegin``1(Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult})">
<summary>
 `fromEndBegin doEnd doBegin` is equivalent to `fromBeginEnd doBegin doEnd`.
</summary>
</member>
<member name="M:Hopac.Job.fromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0})">
<summary>
 Creates a job that performs the asynchronous operation defined by the
 given pair of begin and end operations.
</summary>
</member>
<member name="M:Hopac.Job.conIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 then waits for all of the jobs to finish.  The results of the jobs are
 ignored.
</summary>
</member>
<member name="M:Hopac.Job.conCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 returns a list of the results.

 Note that when multiple jobs raise exceptions, then the created job raises
 an `AggregateException`.
</summary>
</member>
<member name="M:Hopac.Job.seqIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence.  The results of the
 jobs are ignored.  See also: `seqCollect`.
</summary>
</member>
<member name="M:Hopac.Job.seqCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence and returns a list of
 the results.  See also: `seqIgnore`.
</summary>
</member>
<member name="M:Hopac.Job.iterateServer``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that starts a separate server job that indefinitely iterates
 the given job constructor starting with the given value.  `iterateServer x
 x2xJ` is equivalent to `iterate x x2xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.foreverServer(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a separate server job that repeats the given job
 indefinitely.  `foreverServer xJ` is equivalent to `forever xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.iterate``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that indefinitely iterates the given job constructor
 starting with the given value.  See also: `iterateServer`, `forever`.
</summary>
</member>
<member name="M:Hopac.Job.foreverIgnore``2(Hopac.Job{``0})">
<summary>
 `foreverIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; forever`.
</summary>
</member>
<member name="M:Hopac.Job.forever``1(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that repeats the given job indefinitely.  See also:
 `foreverServer`, `iterate`.
</summary>
</member>
<member name="M:Hopac.Job.whenDo(System.Boolean,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whenDo b uJ` is equivalent to `if b then uJ else Job.unit ()`.
</summary>
</member>
<member name="M:Hopac.Job.whileDoIgnore``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{``0})">
<summary>
 `whileDoIgnore u2b xJ` is equivalent to `Job.Ignore xJ |&gt; whileDo u2b`.
</summary>
</member>
<member name="M:Hopac.Job.whileDo(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whileDo u2b uJ` creates a job that sequentially executes the `uJ` job as
 long as `u2b ()` returns `true`.
</summary>
</member>
<member name="M:Hopac.Job.forDownToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownToIgnore hi lo i2xJ` is equivalent to `forDownTo hi lo (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forDownTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownTo hi lo i2uJ` creates a job that sequentially iterates from `hi`
 to `lo` (inclusive) and calls the given function to construct jobs that
 will be executed.
</summary>
</member>
<member name="M:Hopac.Job.forUpToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpToIgnore lo hi i2xJ` is equivalent to `forUpTo lo hi (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forUpTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpTo lo hi i2uJ` creates a job that sequentially iterates from `lo` to
 `hi` (inclusive) and calls the given function to construct jobs that will
 be executed.
</summary>
</member>
<member name="M:Hopac.Job.forNIgnore``1(System.Int32,Hopac.Job{``0})">
<summary>
 `forNIgnore n xJ` is equivalent to `Job.Ignore xJ |&gt; forN n`.
</summary>
</member>
<member name="M:Hopac.Job.forN(System.Int32,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that runs the given job sequentially the given number of
 times.
</summary>
</member>
<member name="M:Hopac.Job.catch``1(Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and results in either the ordinary
 result of the job or the exception raised by the job.
</summary>
</member>
<member name="M:Hopac.Job.usingAsync``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements an experimental `use` like construct for asynchronously
 disposable resources.  The `DisposeAsync` method of the asynchronously
 disposable resource is called to construct a job that is later used to
 dispose the resource after the constructed job returns.  See also:
 `abort`, `using`.
</summary>
</member>
<member name="M:Hopac.Job.using``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements the `use` construct for jobs.  The `Dispose` method of the
 given disposable object is called after running the job constructed with
 the disposable object.  See also: `abort`, `usingAsync`.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyJob``1(Hopac.Job{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a job, is executed after the job
 has been run, whether it fails or completes successfully.

 Note that the workflow notation of F# does not support this operation.  It
 only supports the weaker `tryFinallyFun` operation.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyFun``1(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a function, is executed after
 the job has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryWith``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1})">
<summary>
 Implements the try-with exception handling construct for jobs.
</summary>
</member>
<member name="M:Hopac.Job.tryIn``4(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for jobs.
 Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success, and `exn -&gt;
 Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.
</summary>
</member>
<member name="M:Hopac.Job.raises``1(System.Exception)">
<summary>
 Creates a job that has the effect of raising the specified exception.
 `raises e` is equivalent to `Job.delayWith raise e`.
</summary>
</member>
<member name="M:Hopac.Job.abort``1">
<summary>
 Creates a job that immediately terminates the current job.  See also:
 `startWithFinalizer`.
</summary>
</member>
<member name="M:Hopac.Job.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and maps the result of the job with
 the given function.  This is the same as `|&gt;&gt;` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.join``2(Hopac.Job{``0})">
<summary>
 `join xJJ` is equivalent to `bind id xJJ`.
</summary>
</member>
<member name="M:Hopac.Job.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that first runs the given job and then passes the result of
 that job to the given function to build another job which will then be
 run.  This is the same as `&gt;&gt;=` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.result``1(``0)">
<summary>
 Creates a job with the given result.
</summary>
</member>
<member name="M:Hopac.Job.unit">
<summary>
 Returns a job that does nothing and returns `()`.  `unit ()` is an
 optimized version of `result ()`.
</summary>
</member>
<member name="M:Hopac.Job.Ignore``1(Hopac.Job{``0})">
<summary>
 `Ignore xJ` is equivalent to `xJ |&gt;&gt; fun _ -&gt; ()`.
</summary>
</member>
<member name="M:Hopac.Job.thunk``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that invokes the given thunk to compute the result of the
 job.  `thunk u2x` is equivalent to `result () |&gt;&gt; u2x`.
</summary>
</member>
<member name="M:Hopac.Job.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to
 compute the result of the job.  `lift x2y x` is equivalent to `result x
 |&gt;&gt; x2y`.
</summary>
</member>
<member name="M:Hopac.Job.delayWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to build
 a job that will then be run.  `delayWith x2yJ x` is equivalent to `result
 x &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Job.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function to build a job that will then
 be run.  `delay u2xJ` is equivalent to `result () &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizerIgnore``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 `startWithFinalizerIgnore finalizerJ xJ` is equivalent to `Job.Ignore xJ
 |&gt; startWithFinalizer finalizerJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizer(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `Job.startWithFinalizer finalizerJ uJ` is like `Job.start uJ`, but
 attaches a finalizer to the started job.  The finalizer job is started as
 a separate job in case the started job does not return succesfully or
 raise an exception and is garbage collected.  If the job either returns
 normally or raises an exception, the finalizer job is not started.  See
 also: `Proc`.
</summary>
</member>
<member name="M:Hopac.Job.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `Job.start`, but the given job is known never to return normally, so
 the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Job.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Job.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that schedules the given job to be run as a separate
 concurrent job.  Use `Promise.queue` if you need to be able to get the
 result.  See also: `Proc.queue`.
</summary>
</member>
<member name="M:Hopac.Job.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Job.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job.  Use `Promise.start` if you need to be able to get the
 result.  Use `Job.server` if the job never returns normally.  See also:
 `Job.queue`, `Proc.start`.
</summary>
</member>
<member name="M:Hopac.Job.Random.get">
<summary>
 Returns a job that generates a pseudo random 64-bit unsigned integer.
</summary>
</member>
<member name="M:Hopac.Job.Random.map``1(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `map r2x` is equivalent to `bind (r2x &gt;&gt; result)`.
</summary>
</member>
<member name="M:Hopac.Job.Random.bind``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `bind r2xJ` creates a job that calls the given job constructor with a
 pseudo random 64-bit unsigned integer.
</summary>
</member>
<member name="T:Hopac.Job.Random">
<summary>
 Operations on the built-in pseudo random number generator (PRNG) of Hopac.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessMultiplyGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that either runs the given jobs sequentially, like `&lt;&amp;&gt;`,
 or as two separate parallel jobs and returns a pair of their results.

 Note that when the jobs are run in parallel and both of them raise an
 exception then the created job raises an `AggregateException`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessAmpGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and then returns a pair of
 their results.  `xJ &lt;&amp;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;= fun
 y -&gt; result (x, y)`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterBang``2(Hopac.Job{``0},System.Exception)">
<summary>
 Creates a job that runs the given job and then raises the given
 exception.  `xJ &gt;&gt;! e` is equivalent to `xJ &gt;&gt;= fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterPercent``2(Hopac.Job{``0},``1)">
<summary>
 Creates a job that runs the given job and then returns the given value.
 `xJ &gt;&gt;% y` is an optimized version of `xJ &gt;&gt;= fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_BarGreaterGreater``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that runs the given job and maps the result of the job
 with the given function.  `xJ |&gt;&gt; x2y` is an optimized version of `xJ
 &gt;&gt;= (x2y &gt;&gt; result)`.  This is the same as `map` with the arguments
 flipped.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_DotGreaterGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 first job.  `xJ .&gt;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterDot``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 second job.  `xJ &gt;&gt;. yJ` is equivalent to `xJ &gt;&gt;= fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterEquals``3(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that first runs the given job and then passes the result
 of that job to the given function to build another job which will then
 be run.  This is the same as `bind` with the arguments flipped.
</summary>
</member>
<member name="T:Hopac.Job.Infixes">
<summary>
 Infix operators on jobs.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.Global.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or
 fail.
</summary>
</member>
<member name="M:Hopac.Job.Global.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `Job.Global.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.server` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Job.Global.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the job for execution on the global scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Job.Global.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.startWithActions``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  Upon the failure or success of the job, one of
 the given actions is called once.  See also: `abort`.

 Note that using this function in a job workflow is not optimal and you
 should instead use `Job.start` with the desired exception handling
 construct (e.g. `Job.tryIn` or `Job.catch`).
</summary>
</member>
<member name="T:Hopac.Job.Global">
<summary>
 Operations on the global scheduler.

 Note that in a typical program there should only be a few points (maybe
 just one) where jobs are started or run outside of job workflows.
</summary>
</member>
<member name="T:Hopac.Job">
<summary>
 Operations on jobs.
</summary>
</member>
<member name="M:Hopac.Latch.await(Hopac.Latch)">
<summary>
 Returns an alternative that becomes available once the latch opens.
</summary>
</member>
<member name="M:Hopac.Latch.decrement(Hopac.Latch)">
<summary>
 Returns a job that explicitly decrements the counter of the latch.  When
 the counter reaches `0`, the latch becomes open and operations awaiting
 the latch are resumed.
</summary>
</member>
<member name="M:Hopac.Latch.queueAsPromise``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  A promise is returned for observing the result or failure
 of the queued job.
</summary>
</member>
<member name="M:Hopac.Latch.queue(Hopac.Latch,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  See also `Latch.queueAsAlt`.
</summary>
</member>
<member name="M:Hopac.Latch.holding``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job holding the specified latch.  Note
 that the latch is only held while the given job is being run.  See also
 `Latch.queue`.
</summary>
</member>
<member name="M:Hopac.Latch.within``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Latch,``0})">
<summary>
 Creates a job that creates a new latch, passes it to the given function to
 create a new job to run and then awaits for the latch to open.
</summary>
</member>
<member name="M:Hopac.Latch.Now.increment(Hopac.Latch)">
<summary>
 Increments the counter of the latch.
</summary>
</member>
<member name="M:Hopac.Latch.Now.create(System.Int32)">
<summary>
 Creates a new latch with the specified initial count.
</summary>
</member>
<member name="T:Hopac.Latch.Now">
<summary>
 Immediate operations on latches.
</summary>
</member>
<member name="T:Hopac.Latch">
<summary>
 Operations on latches.
</summary>
</member>
<member name="M:Hopac.Lock.duringJob``1(Hopac.Lock,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job so that the lock is held during the
 execution of the given job.
</summary>
</member>
<member name="M:Hopac.Lock.duringFun``1(Hopac.Lock,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function so that the lock is held
 during the execution of the function.
</summary>
</member>
<member name="M:Hopac.Lock.create">
<summary>
 Creates a job that creates a new mutual exclusion lock.
</summary>
</member>
<member name="M:Hopac.Lock.Now.create">
<summary>
 Creates a new lock.
</summary>
</member>
<member name="T:Hopac.Lock.Now">
<summary>
 Immediate or non-workflow operations on locks.
</summary>
</member>
<member name="T:Hopac.Lock">
<summary>
 Operations on mutual exclusion locks.
</summary>
</member>
<member name="M:Hopac.MVar.take``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, takes the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.read``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, read the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.modifyJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.MVar{``0})">
<summary>
 Creates a job that takes the value of the serialized variable and then
 fills the variable with the result of performing the given job.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.modifyFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,``1}},Hopac.MVar{``0})">
<summary>
 Creates a job that takes the value of the serialized variable and then
 fills the variable with the result of performing the given function.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.fill``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.
</summary>
</member>
<member name="M:Hopac.MVar.createFull``1(``0)">
<summary>
 Creates a job that creates a new serialized variable that initially
 contains the given value.
</summary>
</member>
<member name="M:Hopac.MVar.create``1">
<summary>
 Creates a job that creates a new serialized variable that is initially
 empty.
</summary>
</member>
<member name="M:Hopac.MVar.Now.createFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given
 value.
</summary>
</member>
<member name="M:Hopac.MVar.Now.create``1">
<summary>
 Creates a new serialized variable that is initially empty.
</summary>
</member>
<member name="T:Hopac.MVar.Now">
<summary>
 Immediate or non-workflow operations on serialized variables.
</summary>
</member>
<member name="T:Hopac.MVar">
<summary>
 Operations on serialized variables.
</summary>
</member>
<member name="M:Hopac.Mailbox.take``1(Hopac.Mailbox{``0})">
<summary>
 Creates an alternative that becomes available when the mailbox contains at
 least one value and, if committed to, takes a value from the mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.
</summary>
</member>
<member name="M:Hopac.Mailbox.create``1">
<summary>
 Creates a job that creates a new mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.Global.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Sends the given value to the specified mailbox.

 Note that using this function in a job workflow is not optimal and you
 should use `Mailbox.send` instead.
</summary>
</member>
<member name="T:Hopac.Mailbox.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Mailbox.Now.create``1">
<summary>
 Creates a new mailbox.
</summary>
</member>
<member name="T:Hopac.Mailbox.Now">
<summary>
 Immediate or non-workflow operations on buffered mailboxes.
</summary>
</member>
<member name="T:Hopac.Mailbox">
<summary>
 Operations on buffered mailboxes.
</summary>
</member>
<member name="M:Hopac.Proc.join(Hopac.Proc)">
<summary>
 Returns an alternative that becomes available once the process is known to
 have been terminated for any reason.
</summary>
</member>
<member name="M:Hopac.Proc.self">
<summary>
 Returns a job that returns the current process.
</summary>
</member>
<member name="M:Hopac.Proc.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Proc.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues a new process.  See also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Proc.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Proc.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a new process.  See also: `queue`, `Job.start`.
</summary>
</member>
<member name="T:Hopac.Proc">
<summary>
 Operations on processes.
</summary>
</member>
<member name="M:Hopac.Promise.read``1(Hopac.Promise{``0})">
<summary>
 Creates an alternative for reading the promise.  If the promise was
 delayed, it is started as a separate job.
</summary>
</member>
<member name="M:Hopac.Promise.queue``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is scheduled to be run as a separate concurrent job.  See
 also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.start``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is immediately started to run as a separate concurrent
 job.  See also: `queue`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.Now.get``1(Hopac.Promise{``0})">
<summary>
 Returns the value or raises the failure exception that the promise has
 been fulfilled with.  It is considered an error if the promise has not
 yet been fulfilled.

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.isFulfilled``1(Hopac.Promise{``0})">
<summary>
 Returns true iff the given promise has already been fulfilled (either
 with a value or with a failure).

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withFailure``1(System.Exception)">
<summary>
 Creates a promise with the given failure exception.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withValue``1(``0)">
<summary>
 Creates a promise with the given value.
</summary>
</member>
<member name="M:Hopac.Promise.Now.delay``1(Hopac.Job{``0})">
<summary>
 Creates a promise whose value is computed lazily with the given job when
 an attempt is made to read the promise.  Although the job is not started
 immediately, the effect is that the delayed job will be run as a
 separate job, which means it is possible to communicate with it as long
 the delayed job is started before trying to communicate with it.
</summary>
</member>
<member name="T:Hopac.Promise.Now">
<summary>
 Immediate or non-workflow operations on promises.
</summary>
</member>
<member name="T:Hopac.Promise">
<summary>
 Operations on promises.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.TopLevelHandler">
<summary>
 Specifies the top level exception handler job constructor of the
 scheduler.  When a job fails with an otherwise unhandled exception,
 the job is killed and a new job is constructed with the top level
 handler constructor and then started.  To avoid infinite loops, in
 case the top level handler job raises exceptions, it is simply killed
 after printing a message to the console.  The default top level
 handler simply prints out a message to the console.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.NumWorkers">
<summary>
 Number of worker threads.  Using more than
 `Environment.ProcessorCount` is not optimal and may, in some cases,
 significantly reduce performance.  The default is
 `Environment.ProcessorCount`.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.MaxStackSize">
<summary>
 Specifies the maximum stack size for worker threads.  The default
 is to use the default maximum stack size of the `Thread` class.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.IdleHandler">
<summary>
 Specifies the idle handler for workers.  The worker idle handler is
 run whenever an individual worker runs out of work.  The idle handler
 must return an integer value that specifies how many milliseconds the
 worker is allowed to sleep.  `Timeout.Infinite` puts the worker into
 sleep until the scheduler explicitly wakes it up.  `0` means that the
 idle handler found some new work and the worker should immediately
 look for it.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Foreground">
<summary>
 Specifies whether worker threads are run as background threads or as
 foreground threads.  The default is to run workers as background
 threads.  If you want to run worker threads as foreground threads,
 then you will have to explicitly kill the worker threads.  Using
 foreground threads is probably preferable if your application
 dynamically creates and kills local schedulers to make sure the
 worker threads are properly killed.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Def">
<summary>
 Default options.
</summary>
</member>
<member name="T:Hopac.Scheduler.Create">
<summary>
 A record of scheduler configuration options.
</summary>
</member>
<member name="M:Hopac.Scheduler.kill(Hopac.Scheduler)">
<summary>
 Kills the worker threads of the scheduler one-by-one.  This should only be
 used with a local scheduler that is known to be idle.
</summary>
</member>
<member name="M:Hopac.Scheduler.wait(Hopac.Scheduler)">
<summary>
 Waits until the scheduler becomes completely idle.

 Note that for this to make sense, the scheduler should be a local
 scheduler that your program manages explicitly.
</summary>
</member>
<member name="M:Hopac.Scheduler.server(Hopac.Scheduler,Hopac.Job{Hopac.Void})">
<summary>
 Like `Scheduler.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Scheduler.queueIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Scheduler.queue(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Scheduler.start(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job, but does not wait for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startWithActions``1(Hopac.Scheduler,Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job, but does not wait for the job to finish.
 Upon the failure or success of the job, one of the given actions is called
 once.  See also: `abort`.

 Note that using this function in a job workflow is not optimal and you
 should instead use `Job.start` with desired Job exception handling
 construct (e.g. `Job.tryIn` or `Job.catch`).
</summary>
</member>
<member name="M:Hopac.Scheduler.create(Hopac.Scheduler.Create)">
<summary>
 Creates a new local scheduler.

 Note that a local scheduler does not automatically implement services such
 as the global wall-clock timer.
</summary>
</member>
<member name="M:Hopac.Scheduler.Global.setCreate(Hopac.Scheduler.Create)">
<summary>
 Sets options for creating the global scheduler.  This must be called
 before invoking any Hopac functionality that implicitly creates the
 global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler">
<summary>
 Operations on schedulers.  Use of this module requires more intimate
 knowledge of Hopac, but may allow adapting Hopac to special application
 requirements.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOutMillis(System.Int32)">
<summary>
 `timeOutMillis n` is equivalent to `timeOut (TimeSpan.FromMilliseconds
 (double n))`.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOut(System.TimeSpan)">
<summary>
 Creates an alternative that, after instantiation, becomes available
 after the specified time span.

 Note that this is simply not intended for high precision timing and the
 resolution of the underlying timing mechanism is very coarse (Windows
 system ticks).

 Note that you do not need to create a new timeout alternative every time
 you need a timeout with a specific time span.
</summary>
</member>
<member name="T:Hopac.Timer.Global">
<summary>
 Operations on the global wall-clock timer.  The global timer is implicitly
 associated with the global scheduler.
</summary>
</member>
<member name="T:Hopac.Timer">
<summary>
 Operations on a wall-clock timer.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvarFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given value.
 This is the same function as `MVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvar``1">
<summary>
 Creates a serialized variable that is initially empty.  This is the same
 function as `MVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivarFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.  This is the same
 function as `IVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivar``1">
<summary>
 Creates a new write once variable.  This is the same function as
 `IVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mb``1">
<summary>
 Creates a new mailbox.  This is the same function as
 `Mailbox.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ch``1">
<summary>
 Creates a new channel.  This is the same function as `Ch.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asJob``1(Hopac.Job{``0})">
<summary>
 Use object as job.  This function is a NOP and is provided as a kind of
 syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asAlt``1(Hopac.Alt{``0})">
<summary>
 Use object as alternative.  This function is a NOP and is provided as a
 kind of syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `start`, but the given job is known never to return normally, so the
 job can be spawned in an even more lightweight manner.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.server` instead.

 This is the same function as `Job.Global.server`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the global scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.

 This is the same function as `Job.Global.queue`.
</summary>
</member>
<member name="M:Hopac.TopLevel.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.TopLevel.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.

 This is the same function as `Job.Global.start`.
</summary>
</member>
<member name="M:Hopac.TopLevel.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or fail.
</summary>
</member>
<member name="P:Hopac.TopLevel.job">
<summary>
 Default expression builder for jobs.
</summary>
</member>
<member name="T:Hopac.TopLevel">
<summary>
 Convenience bindings for programming with Hopac.
</summary>
</member>
</members>
</doc>
